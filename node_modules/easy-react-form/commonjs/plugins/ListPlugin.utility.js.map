{"version":3,"sources":["../../source/plugins/ListPlugin.utility.js"],"names":["convertListValues","getListValue","getFieldName","LIST_ITEM_KEY_REGEXP","values","actualValues","listNames","Object","keys","key","value","match","unused","list","index","name","indexOf","push","listName","filter","_","NOT_FOUND","i"],"mappings":";;;;;;;;QAuBgBA,iB,GAAAA,iB;QAgDAC,Y,GAAAA,Y;QAcAC,Y,GAAAA,Y;;AArFhB;;AAEA,IAAMC,uBAAuB,yBAA7B;;AAEA;;;;;;;;;;;;;;;;;;;AAmBO,SAASH,iBAAT,CAA2BI,MAA3B,EAAmC;AACzC;AACA,KAAMC,eAAe,EAArB;AACA,KAAMC,YAAY,EAAlB;AACA,sBAAkBC,OAAOC,IAAP,CAAYJ,MAAZ,CAAlB,kHAAuC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,MAA5BK,GAA4B;;AACtC,MAAMC,QAAQN,OAAOK,GAAP,CAAd;AACA,MAAME,QAAQF,IAAIE,KAAJ,CAAUR,oBAAV,CAAd;AACA,MAAIQ,KAAJ,EAAW;AAAA,+BAMNA,KANM;AAAA,OAETC,MAFS;AAAA,OAGTC,IAHS;AAAA,OAITC,KAJS;AAAA,OAKTC,IALS;;AAOV,OAAI,CAACV,aAAaQ,IAAb,CAAL,EAAyB;AACxBR,iBAAaQ,IAAb,IAAqB,EAArB;AACA;AACD,OAAI,CAACR,aAAaQ,IAAb,EAAmBC,KAAnB,CAAL,EAAgC;AAC/BT,iBAAaQ,IAAb,EAAmBC,KAAnB,IAA4B,EAA5B;AACA;AACDT,gBAAaQ,IAAb,EAAmBC,KAAnB,EAA0BC,IAA1B,IAAkCL,KAAlC;AACA,OAAIJ,UAAUU,OAAV,CAAkBH,IAAlB,IAA0B,CAA9B,EAAiC;AAChCP,cAAUW,IAAV,CAAeJ,IAAf;AACA;AACD,GAjBD,MAiBO;AACNR,gBAAaI,GAAb,IAAoBC,KAApB;AACA;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuBJ,SAAvB,yHAAkC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,MAAvBY,QAAuB;;AACjCb,eAAaa,QAAb,IAAyBb,aAAaa,QAAb,EAAuBC,MAAvB,CAA8B;AAAA,UAAKC,CAAL;AAAA,GAA9B,CAAzB;AACA;AACD,QAAOf,YAAP;AACA;;AAED;;;;;;;AAOO,SAASJ,YAAT,CAAsBG,MAAtB,EAA8BK,GAA9B,EAAmC;AACzC,KAAME,QAAQF,IAAIE,KAAJ,CAAUR,oBAAV,CAAd;AACA,KAAIQ,KAAJ,EAAW;AAAA,+BAMNA,KANM;AAAA,MAETC,MAFS;AAAA,MAGTC,IAHS;AAAA,MAITC,KAJS;AAAA,MAKTC,IALS;;AAOV,SAAOX,OAAOS,IAAP,KAAgBT,OAAOS,IAAP,EAAaC,KAAb,CAAhB,IAAuCV,OAAOS,IAAP,EAAaC,KAAb,EAAoBC,IAApB,CAA9C;AACA;AACD,QAAOM,kBAAP;AACA;;AAEM,SAASnB,YAAT,CAAsBgB,QAAtB,EAAgCI,CAAhC,EAAmCP,IAAnC,EAAyC;AAC/C,QAAUG,QAAV,SAAsBI,CAAtB,SAA2BP,IAA3B;AACA","file":"ListPlugin.utility.js","sourcesContent":["import { NOT_FOUND } from '../utility'\r\n\r\nconst LIST_ITEM_KEY_REGEXP = /^([^:]+):(\\d+):([^:]+)$/\r\n\r\n/**\r\n * Converts values having keys `${list}:${i}:${field}`\r\n * into arrays of objects `{ list: [{ field, ... }, ...] }`.\r\n *\r\n * For example, in a form, there's a `<List name=\"list\">` container element\r\n * and inside that container element there're 3 `<Field name=\"value\"/>` elements.\r\n *\r\n * Then, in `values` argument, there'd be 3 fields names corresponding to those list items:\r\n * * \"list:0:value\": \"a\"\r\n * * \"list:1:value\": \"b\"\r\n * * \"list:2:value\": \"c\"\r\n *\r\n * After calling this function, a new `values` object is returned\r\n * where those 3 entries have been replaced with a single entry:\r\n * * \"list\": [{ value: \"a\" }, { value: \"c\" }]\r\n *\r\n * @param {object} values\r\n * @return {object}\r\n */\r\nexport function convertListValues(values) {\r\n\t// `values` are converted to `actualValues`.\r\n\tconst actualValues = {}\r\n\tconst listNames = []\r\n\tfor (const key of Object.keys(values)) {\r\n\t\tconst value = values[key]\r\n\t\tconst match = key.match(LIST_ITEM_KEY_REGEXP)\r\n\t\tif (match) {\r\n\t\t\tconst [\r\n\t\t\t\tunused,\r\n\t\t\t\tlist,\r\n\t\t\t\tindex,\r\n\t\t\t\tname\r\n\t\t\t] = match\r\n\t\t\tif (!actualValues[list]) {\r\n\t\t\t\tactualValues[list] = []\r\n\t\t\t}\r\n\t\t\tif (!actualValues[list][index]) {\r\n\t\t\t\tactualValues[list][index] = {}\r\n\t\t\t}\r\n\t\t\tactualValues[list][index][name] = value\r\n\t\t\tif (listNames.indexOf(list) < 0) {\r\n\t\t\t\tlistNames.push(list)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tactualValues[key] = value\r\n\t\t}\r\n\t}\r\n\t// Compact lists: remove removed items.\r\n\t// When an item is removed indexes are not shifted.\r\n\t// Example:\r\n\t// \"list:0:value\": \"a\"\r\n\t// \"list:2:value\": \"c\"\r\n\t// Result:\r\n\t// \"list\": [{ value: \"a\" }, { value: \"c\" }]\r\n\tfor (const listName of listNames) {\r\n\t\tactualValues[listName] = actualValues[listName].filter(_ => _)\r\n\t}\r\n\treturn actualValues\r\n}\r\n\r\n/**\r\n * Gets a value by path `${list}:${i}:${field}`\r\n * from an object having shape `{ list: [{ field, ... }, ...] }`.\r\n * @param {object} values\r\n * @param {string} key\r\n * @return {any} Returns `NOT_FOUND` if the value wasn't found.\r\n */\r\nexport function getListValue(values, key) {\r\n\tconst match = key.match(LIST_ITEM_KEY_REGEXP)\r\n\tif (match) {\r\n\t\tconst [\r\n\t\t\tunused,\r\n\t\t\tlist,\r\n\t\t\tindex,\r\n\t\t\tname\r\n\t\t] = match\r\n\t\treturn values[list] && values[list][index] && values[list][index][name]\r\n\t}\r\n\treturn NOT_FOUND\r\n}\r\n\r\nexport function getFieldName(listName, i, name) {\r\n\treturn `${listName}:${i}:${name}`\r\n}"]}