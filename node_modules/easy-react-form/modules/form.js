'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.contextPropType = exports.default = exports.Context = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp, _initialiseProps;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createReactContext = require('create-react-context');

var _createReactContext2 = _interopRequireDefault(_createReactContext);

var _OnAbandonPlugin = require('./plugins/OnAbandonPlugin');

var _OnAbandonPlugin2 = _interopRequireDefault(_OnAbandonPlugin);

var _ListPlugin = require('./plugins/ListPlugin');

var _ListPlugin2 = _interopRequireDefault(_ListPlugin);

var _utility = require('./utility');

var _actions = require('./actions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Context = exports.Context = (0, _createReactContext2.default)();

var Form = (_temp = _class = function (_Component) {
	_inherits(Form, _Component);

	function Form(props) {
		_classCallCheck(this, Form);

		var _this = _possibleConstructorReturn(this, (Form.__proto__ || Object.getPrototypeOf(Form)).call(this, props));

		_initialiseProps.call(_this);

		var _this$props = _this.props,
		    values = _this$props.values,
		    requiredMessage = _this$props.requiredMessage,
		    plugins = _this$props.plugins,
		    wait = _this$props.wait;

		_this.state = _extends({
			resetCounter: 0
		}, generateInitialFormState(values, { submitting: wait }), {
			dispatch: _this.dispatch,
			onRegisterField: _this.onRegisterField,
			onUnregisterField: _this.onUnregisterField,
			getSubmittedValue: _this.getSubmittedValue,
			getRequiredMessage: function getRequiredMessage() {
				return requiredMessage;
			},
			// These're used by `<List/>`.
			focus: _this.focus,
			getValues: _this.values
		});
		_this.plugins = plugins.map(function (Plugin) {
			return new Plugin(function () {
				return _this.props;
			}, function () {
				return _this.state;
			});
		});
		for (var _iterator = _this.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
			var _ref;

			if (_isArray) {
				if (_i >= _iterator.length) break;
				_ref = _iterator[_i++];
			} else {
				_i = _iterator.next();
				if (_i.done) break;
				_ref = _i.value;
			}

			var plugin = _ref;

			if (plugin.initContext) {
				plugin.initContext(_this.state);
			}
		}
		return _this;
	}

	// Stores fields' `validate()` functions which are used
	// when calling `set(field, value)` and `clear(field)`.
	// Also stores fields' `scroll()` and `focus()` functions.


	_createClass(Form, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var autoFocus = this.props.autoFocus;


			this.mounted = true;

			// First `form.constructor` is called,
			// then `form.componentWillMount` is called,
			// then `field.constructor` is called,
			// then `field.componentWillMount` is called,
			// then `field.componentDidMount` is called,
			// then `form.componentDidMount` is called.

			for (var _iterator2 = this.plugins, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
				var _ref2;

				if (_isArray2) {
					if (_i2 >= _iterator2.length) break;
					_ref2 = _iterator2[_i2++];
				} else {
					_i2 = _iterator2.next();
					if (_i2.done) break;
					_ref2 = _i2.value;
				}

				var plugin = _ref2;

				if (plugin.onMount) {
					plugin.onMount();
				}
			}

			// Autofocus the form when it's mounted and all of its fields are initialized.
			if (autoFocus) {
				this.focus();
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			var wait = this.props.wait;

			if (wait !== prevProps.wait) {
				this.setFormSubmitting(wait);
			}
			this.cleanUpRemovedFields();
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			for (var _iterator3 = this.plugins, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
				var _ref3;

				if (_isArray3) {
					if (_i3 >= _iterator3.length) break;
					_ref3 = _iterator3[_i3++];
				} else {
					_i3 = _iterator3.next();
					if (_i3.done) break;
					_ref3 = _i3.value;
				}

				var plugin = _ref3;

				if (plugin.onUnmount) {
					plugin.onUnmount();
				}
			}
			this.mounted = false;
		}
	}, {
		key: 'updateState',
		value: function updateState(newState, callback) {
			// See if any fields are watched.
			// If they are, see if their values have changed.
			// If they have, re-render the form after updating state.
			for (var _iterator4 = this.watchedFieldsList, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
				var _ref4;

				if (_isArray4) {
					if (_i4 >= _iterator4.length) break;
					_ref4 = _iterator4[_i4++];
				} else {
					_i4 = _iterator4.next();
					if (_i4.done) break;
					_ref4 = _i4.value;
				}

				var field = _ref4;

				var prevValue = this.state.values[field];
				var newValue = newState.values[field];
				if (newValue !== prevValue) {
					// Re-render the form after updating state.
					newState = _extends({}, newState);
					break;
				}
			}
			// Update state.
			this.setState(newState, callback);
		}

		// `value` parameter is an initial field value.
		// It is used later in case of a form or field reset.


		/**
   * `callback` is currently only used when calling
   * `context.dispatch(setFormSubmitting(false))`.
   * @param  {function}   action â€” A function of `state`.
   * @param  {function} callback
   */


		// Public API
		/**
   * Returns form field values.
   * @return {object}
   */

	}, {
		key: 'applyPluginValueTransforms',


		/**
   * Applies plugins' transformations to form field values.
   * @param  {object} values
   * @return {object}
   */
		value: function applyPluginValueTransforms(values) {
			for (var _iterator5 = this.plugins, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
				var _ref5;

				if (_isArray5) {
					if (_i5 >= _iterator5.length) break;
					_ref5 = _iterator5[_i5++];
				} else {
					_i5 = _iterator5.next();
					if (_i5.done) break;
					_ref5 = _i5.value;
				}

				var plugin = _ref5;

				if (plugin.getValues) {
					values = plugin.getValues(values);
				}
			}
			return values;
		}

		// Public API


		// Not tested.


		// Is called when the form has been submitted.

	}, {
		key: 'searchForInvalidField',
		value: function searchForInvalidField() {
			var _state = this.state,
			    fields = _state.fields,
			    values = _state.values,
			    errors = _state.errors;

			// Re-run `validate()` for each field.
			// Because `validate()` function takes two arguments:
			// the current field value and all form field values,
			// and at the same time it's only called in field's `onChange`,
			// therefore other form field values could change since then
			// and that particular `validate()` wouldn't get called
			// without this explicit "revalidate all fields before submit".

			for (var _iterator6 = Object.keys(fields), _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
				var _ref6;

				if (_isArray6) {
					if (_i6 >= _iterator6.length) break;
					_ref6 = _iterator6[_i6++];
				} else {
					_i6 = _iterator6.next();
					if (_i6.done) break;
					_ref6 = _i6.value;
				}

				var field = _ref6;

				// If the field is not mounted then ignore it.
				if (!fields[field]) {
					continue;
				}
				// Check for an externally set `error`.
				if (errors[field] !== undefined) {
					return field;
				}
				// If the field's `value` is not valid,
				// `validate(value)` returns a validation error message (or `true`).
				if (this.fields[field].validate(values[field])) {
					return field;
				}
			}
		}
	}, {
		key: 'validate',
		value: function validate() {
			var _this2 = this;

			var scrollDuration = this.props.scrollDuration;
			var _state2 = this.state,
			    fields = _state2.fields,
			    values = _state2.values;

			// Are there any invalid fields.
			// Returns the first one.

			var field = this.searchForInvalidField();

			if (!field) {
				return true;
			}

			// Re-validate all fields to highlight all required ones that're empty.
			// Otherwise, it'd just stop at the first not-valid field
			// and the user would just see that single field highlighted
			// as "Required", and then they'd have to re-submit the form
			// just to find out that some other field is "Required" too,
			// so it's better "user experience" to just highlight all
			// required fields right away.
			for (var _iterator7 = Object.keys(fields), _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
				var _ref7;

				if (_isArray7) {
					if (_i7 >= _iterator7.length) break;
					_ref7 = _iterator7[_i7++];
				} else {
					_i7 = _iterator7.next();
					if (_i7.done) break;
					_ref7 = _i7.value;
				}

				var _field = _ref7;

				// Trigger `validate()` on the field
				// so that `errors` is updated inside form state.
				// (if the field is still mounted)
				if (fields[_field]) {
					this.set(_field, values[_field]);
				}
			}

			// Scroll to the invalid field.
			this.scroll(field, { duration: scrollDuration });

			// Focus the invalid field after it has been scrolled to.
			setTimeout(function () {
				if (_this2.mounted) {
					// Focus the invalid field.
					_this2.focus(field);
				}
			}, scrollDuration);

			// The form is invalid.
			return false;
		}

		/**
   * Collects the currently "registered" fields' values.
   * @return {object} `values`
   */

	}, {
		key: 'getSubmittedValues',
		value: function getSubmittedValues() {
			var _state3 = this.state,
			    fields = _state3.fields,
			    values = _state3.values;
			// Get only "registered" (non-removed) field values.

			var fieldValues = (0, _utility.getValues)(values, fields);
			for (var _iterator8 = Object.keys(fieldValues), _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
				var _ref8;

				if (_isArray8) {
					if (_i8 >= _iterator8.length) break;
					_ref8 = _iterator8[_i8++];
				} else {
					_i8 = _iterator8.next();
					if (_i8.done) break;
					_ref8 = _i8.value;
				}

				var key = _ref8;

				// Trim strings (if `trim` option is set to `true`, which is the default setting).
				// Convert empty strings to `null`s.
				fieldValues[key] = this.getSubmittedValue(fieldValues[key]);
			}
			// Apply plugins' value transformations.
			return this.applyPluginValueTransforms(fieldValues);
		}

		// Calls `<form/>`'s `onSubmit` action.

	}, {
		key: 'executeFormAction',
		value: function executeFormAction(action, values) {
			var onError = this.props.onError;

			var result = void 0;
			try {
				result = action(values);
			} catch (error) {
				if (onError(error) === false) {
					throw error;
				}
			}
			// If the form submit action returned a `Promise`
			// then track this `Promise`'s progress.
			if (result && typeof result.then === 'function') {
				this.onSubmitPromise(result).then(this.onAfterSubmit);
			} else {
				this.onAfterSubmit();
			}
		}
	}, {
		key: 'snapshotFocus',
		value: function snapshotFocus() {
			// On Mac, elements that aren't text input elements
			// tend not to get focus assigned to them.
			// Therefore, if the submit button was clicked to submit the form
			// then `document.activeElement` will still be `<body/>`.
			this.focusableBeforeSubmit = document.activeElement;
			if (!document.activeElement || document.activeElement === document.body) {
				this.focusableBeforeSubmit = this.getSubmitButtonNode();
			}
		}
	}, {
		key: 'restoreFocus',
		value: function restoreFocus(force) {
			if (force || !document.activeElement || document.activeElement === document.body) {
				// The `<input/>` field might have been remounted right after form submit,
				// for example, if the developer calls `form.reset()` in `onSubmit()`.
				if (this.focusableBeforeSubmit instanceof Element && !document.body.contains(this.focusableBeforeSubmit)) {
					this.focusableBeforeSubmit = undefined;
				}
				if (this.focusableBeforeSubmit) {
					this.focusableBeforeSubmit.focus();
					this.focusableBeforeSubmit = undefined;
				}
			}
		}
	}, {
		key: 'setFormSubmitting',
		value: function setFormSubmitting(submitting, callback, forceRestoreFocus) {
			var _this3 = this;

			this.dispatch((0, _actions.setFormSubmitting)(submitting), function () {
				if (!submitting) {
					_this3.restoreFocus(forceRestoreFocus);
				}
				if (callback) {
					callback();
				}
			});
		}
	}, {
		key: 'resetFormSubmittingState',
		value: function resetFormSubmittingState(forceRestoreFocus) {
			var _this4 = this;

			return new Promise(function (resolve) {
				if (_this4.mounted) {
					var wait = _this4.props.wait;

					_this4.setFormSubmitting(wait, resolve, forceRestoreFocus);
				} else {
					resolve();
				}
			});
		}

		// Is called when `<form/>` `onSubmit` returns a `Promise`.

	}, {
		key: 'onSubmitPromise',
		value: function onSubmitPromise(promise) {
			var _this5 = this;

			// When `submitting` flag is set to `true`
			// all fields and the submit button will become disabled.
			// This results in focus being lost.
			// To preserve focus, the currently focused DOM node is noted
			// and after the form is submitted the focus is restored.
			// The focus must be restored after the form re-renders
			// with `submitting: false`, hence the `.setState()` `Promise`.
			this.snapshotFocus();
			this.setFormSubmitting(true);
			return promise.then(function () {
				return _this5.resetFormSubmittingState();
			}, function (error) {
				return _this5.resetFormSubmittingState(true).then(function () {
					var onError = _this5.props.onError;

					if (onError(error) === false) {
						throw error;
					}
				});
			});
		}

		// Focuses on a given form field (is used internally + public API).

	}, {
		key: 'getFocusable',


		/**
   * Returns a "focusable".
   * @return {(object|Element)} Returns either a `field` object having `.focus()` method or the submit button `Element`.
   */
		value: function getFocusable() {
			if (this.firstField) {
				return this.fields[this.firstField];
			}
			return this.getSubmitButtonNode();
		}

		// Scrolls to a form field (is used internally + public API).


		// Clears field value (public API).
		// If this field hasn't been "registered" yet then ignore.


		// Gets field value (public API).


		// Sets field value (public API).

	}, {
		key: 'render',
		value: function render() {
			var children = this.props.children;
			var _state4 = this.state,
			    resetCounter = _state4.resetCounter,
			    submitting = _state4.submitting;

			return _react2.default.createElement(
				'form',
				_extends({
					key: resetCounter,
					ref: this.setFormNode
				}, (0, _utility.getPassThroughProps)(this.props, Form.propTypes), {
					onSubmit: this.onSubmit }),
				_react2.default.createElement(
					Context.Provider,
					{ value: this.state },
					typeof children === 'function' ? _react2.default.createElement(
						Children,
						{
							values: this.mounted ? this.values() : undefined,
							reset: this.reset,
							set: this.set,
							clear: this.clear,
							scroll: this.scroll,
							focus: this.focus,
							watch: this.watch,
							submitting: submitting },
						children
					) : children
				)
			);
		}
	}]);

	return Form;
}(_react.Component), _class.propTypes = {
	onSubmit: _propTypes2.default.func.isRequired,
	onBeforeSubmit: _propTypes2.default.func,
	onAfterSubmit: _propTypes2.default.func,
	onAbandon: _propTypes2.default.func,
	values: _propTypes2.default.object,
	autoFocus: _propTypes2.default.bool.isRequired,
	trim: _propTypes2.default.bool.isRequired,
	requiredMessage: _propTypes2.default.string.isRequired,
	wait: _propTypes2.default.bool.isRequired,
	onError: _propTypes2.default.func.isRequired,
	scrollDuration: _propTypes2.default.number.isRequired,
	plugins: _propTypes2.default.arrayOf(_propTypes2.default.func).isRequired,
	children: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]).isRequired
}, _class.defaultProps = {
	autoFocus: false,
	trim: true,
	requiredMessage: 'Required',
	wait: false,
	onError: function onError(error) {
		return false;
	},
	scrollDuration: 300,
	plugins: [_OnAbandonPlugin2.default, _ListPlugin2.default] }, _initialiseProps = function _initialiseProps() {
	var _this6 = this;

	this.fields = {};
	this.watchedFields = {};
	this.watchedFieldsList = [];

	this.onRegisterField = function (field, _ref9) {
		var value = _ref9.value,
		    onChange = _ref9.onChange,
		    validate = _ref9.validate,
		    error = _ref9.error,
		    scroll = _ref9.scroll,
		    focus = _ref9.focus;

		if (value === undefined) {
			value = _this6.getInitialValue(field);
		}

		// The stored field info is used to `validate()` field `value`s
		// and set the corresponding `error`s
		// when calling `set(field, value)` and `clear(field)`.
		//
		// If a field happens to register the second time
		// (e.g. as a result of React "reconciliation" because of the order change)
		// then the methods for the field will be updated.
		//
		_this6.fields[field] = {
			initialValue: value,
			validate: validate,
			scroll: scroll,
			focus: focus,
			onChange: onChange
			// This is used for the `autofocus` feature.
		};if (!_this6.firstField) {
			_this6.firstField = field;
		}
		_this6.dispatch((0, _actions.registerField)({
			field: field,
			value: value,
			validate: validate,
			error: error
		}));
	};

	this.onUnregisterField = function (field) {
		_this6.dispatch((0, _actions.unregisterField)(field));
		// Rerender the form so that the field is
		// removed if it's no longer mounted.
		_this6.forceUpdate();
	};

	this.dispatch = function (action, callback) {
		action(_this6.state);

		// A `React.Component` always re-renders on `this.setState()`,
		// even if the `state` hasn't changed.
		// The re-rendering of the `<Form/>` is used to re-render
		// the `<Field/`>s with the updated `value`s.
		// This could potentially result in slower performance
		// on `<Form/>`s with a lots of `<Field/>`s
		// (maybe hundreds or something like that?)
		// but on regular `<Form/>`s I didn't notice any lag.
		// A possible performance optimization could be
		// not calling `this.setState()` for `<Form/>` re-rendering
		// and instead calling something like `this.forceUpdate()`
		// on the `<Field/>` that called `context.dispatch()`.
		//
		// `this.setState()` is called on `this.state`
		// rather than creating a new `state` because `this.state`
		// is used as the `context` property for `React.Context`
		// meaning that `state` reference shouldn't change.
		//
		_this6.updateState(_this6.state, callback);

		// const { onStateChange } = this.props
		// if (onStateChange) {
		// 	onStateChange(this.state)
		// }
	};

	this.getSubmittedValue = function (value) {
		var trim = _this6.props.trim;

		if (trim && typeof value === 'string') {
			value = value.trim();
		}
		// Convert empty strings to `null`.
		//
		// Using `undefined` instead of `null` wouldn't work because the browser
		// wouldn't send such fields to the server because `JSON.stringify()` skips
		// `undefined` properties when converting a JSON object to a string.
		//
		// Sending a `null` field value rather than omitting it entirely from an HTTP request
		// is used in order to be able to "clear" the form field value on the server side.
		//
		if (value === '') {
			value = null;
		}
		return value;
	};

	this.getInitialValue = function (name) {
		var initialValues = _this6.state.initialValues;

		for (var _iterator9 = _this6.plugins, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
			var _ref10;

			if (_isArray9) {
				if (_i9 >= _iterator9.length) break;
				_ref10 = _iterator9[_i9++];
			} else {
				_i9 = _iterator9.next();
				if (_i9.done) break;
				_ref10 = _i9.value;
			}

			var plugin = _ref10;

			if (plugin.getValue) {
				var value = plugin.getValue(initialValues, name);
				if (value !== _utility.NOT_FOUND) {
					return value;
				}
			}
		}
		return (0, _utility.getValue)(initialValues, name);
	};

	this.values = function () {
		var _state5 = _this6.state,
		    values = _state5.values,
		    fields = _state5.fields;

		return _this6.applyPluginValueTransforms((0, _utility.getValues)(values, fields));
	};

	this.reset = function (field) {
		// `<Form/>` `.reset()` instance method no longer accepts `fieldName: string` argument.
		// It still works the old way, but the `fieldName: string` arugment is considered deprecated.
		// It worked in a weird way: reset the field to its initial value rather than `undefined`.
		// To reset a field, use `.clear(fieldName)` instance method instead.
		if (typeof field === 'string') {
			return _this6.resetField(field);
		}

		var _props = _this6.props,
		    autoFocus = _props.autoFocus,
		    plugins = _props.plugins,
		    wait = _props.wait;
		var _state6 = _this6.state,
		    fields = _state6.fields,
		    initialValues = _state6.initialValues,
		    resetCounter = _state6.resetCounter;


		for (var _iterator10 = _this6.plugins, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
			var _ref11;

			if (_isArray10) {
				if (_i10 >= _iterator10.length) break;
				_ref11 = _iterator10[_i10++];
			} else {
				_i10 = _iterator10.next();
				if (_i10.done) break;
				_ref11 = _i10.value;
			}

			var plugin = _ref11;

			if (plugin.onReset) {
				plugin.onReset();
			}
		}

		// `this.setState()` is called on `this.state`
		// rather than creating a new `state` because `this.state`
		// is used as the `context` property for `React.Context`
		// meaning that `state` reference shouldn't change.

		// Changing `resetCounter` results in a complete re-mounting of the `<form/>`,
		// including all of the `<Field/>`s.
		_this6.state.resetCounter = (0, _utility.getNext)(resetCounter);

		// All `<Field/>`s will be re-mounted and re-registered.
		var initialFormState = generateInitialFormState(initialValues, { submitting: wait });
		for (var _iterator11 = Object.keys(initialFormState), _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {
			var _ref12;

			if (_isArray11) {
				if (_i11 >= _iterator11.length) break;
				_ref12 = _iterator11[_i11++];
			} else {
				_i11 = _iterator11.next();
				if (_i11.done) break;
				_ref12 = _i11.value;
			}

			var key = _ref12;

			_this6.state[key] = initialFormState[key];
		}

		// `generateInitialFormState()` produces a state with zero `fields` counters.
		// But, subsequently, the change to `resetCounter` results in  a complete
		// re-mounting of the `<form/>`, including all of the `<Field/>`s, which
		// decrements all `fields` counters.
		// If the current `fields` counters weren't preserved, then the counters
		// would first be decremented to `-1` on unmount, and then incremented to `0`
		// on re-mount, and the form would think that no fields are mounted.
		// Preserving the current non-zero `fields` counters fixes that.
		_this6.state.fields = fields;

		// Reset first focusable field since the form is gonna be reset.
		_this6.firstField = undefined;

		_this6.updateState(_this6.state, function () {
			if (!_this6.mounted) {
				return;
			}
			// Autofocus the form (if not configured otherwise)
			if (autoFocus) {
				// If `reset()` was called inside `onSubmit()`, then
				// don't focus on a field here because it might be `disabled`.
				// Instead, schedule the autofocus for later, when the fields
				// are no longer disabled.
				if (_this6.state.submitting) {
					_this6.focusableBeforeSubmit = _this6.getFocusable();
				} else {
					_this6.focus();
				}
			}
			// Trigger each `<Field/>`'s `onChange()` handler.
			for (var _iterator12 = Object.keys(fields), _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {
				var _ref13;

				if (_isArray12) {
					if (_i12 >= _iterator12.length) break;
					_ref13 = _iterator12[_i12++];
				} else {
					_i12 = _iterator12.next();
					if (_i12.done) break;
					_ref13 = _i12.value;
				}

				var _field2 = _ref13;

				// If the field is still mounted.
				if (_this6.fields[_field2]) {
					var _fields$_field = _this6.fields[_field2],
					    onChange = _fields$_field.onChange,
					    initialValue = _fields$_field.initialValue;

					if (onChange) {
						onChange(initialValue);
					}
				}
			}
		});
	};

	this.resetField = function (name) {
		for (var _iterator13 = _this6.plugins, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {
			var _ref14;

			if (_isArray13) {
				if (_i13 >= _iterator13.length) break;
				_ref14 = _iterator13[_i13++];
			} else {
				_i13 = _iterator13.next();
				if (_i13.done) break;
				_ref14 = _i13.value;
			}

			var plugin = _ref14;

			if (plugin.onResetField) {
				if (plugin.onResetField(name, _this6)) {
					return;
				}
			}
		}
		var initialValue = !_this6.fields[name] || _this6.fields[name].initialValue === undefined ? _this6.getInitialValue(name) : _this6.fields[name].initialValue;
		_this6.dispatch((0, _actions.setFieldValue)(name, initialValue));
		// A default value isn't supposed to generate an error.
		_this6.dispatch((0, _actions.setFieldValidationError)(name, undefined));
		// Trigger the `<Field/>`'s `onChange()` handler.
		// If the field is still mounted.
		if (_this6.fields[name]) {
			var _fields$name = _this6.fields[name],
			    onChange = _fields$name.onChange,
			    _initialValue = _fields$name.initialValue;

			if (onChange) {
				onChange(_initialValue);
			}
		}
	};

	this.removeField = function (field) {
		_this6.dispatch((0, _actions.removeField)(field));
		delete _this6.fields[field];
	};

	this.cleanUpRemovedFields = function () {
		var fields = _this6.state.fields;

		for (var _iterator14 = Object.keys(fields), _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {
			var _ref15;

			if (_isArray14) {
				if (_i14 >= _iterator14.length) break;
				_ref15 = _iterator14[_i14++];
			} else {
				_i14 = _iterator14.next();
				if (_i14.done) break;
				_ref15 = _i14.value;
			}

			var field = _ref15;

			// Remove unmounted `<Field/>`s.
			if (fields[field] === 0) {
				_this6.removeField(field);
			}
		}
	};

	this.onAfterSubmit = function () {
		var onAfterSubmit = _this6.props.onAfterSubmit;

		for (var _iterator15 = _this6.plugins, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {
			var _ref16;

			if (_isArray15) {
				if (_i15 >= _iterator15.length) break;
				_ref16 = _iterator15[_i15++];
			} else {
				_i15 = _iterator15.next();
				if (_i15.done) break;
				_ref16 = _i15.value;
			}

			var plugin = _ref16;

			if (plugin.onAfterSubmit) {
				plugin.onAfterSubmit();
			}
		}
		if (onAfterSubmit) {
			onAfterSubmit();
		}
	};

	this.onSubmit = function (event) {
		var _props2 = _this6.props,
		    onSubmit = _props2.onSubmit,
		    onBeforeSubmit = _props2.onBeforeSubmit;

		// If it's an event handler then `.preventDefault()` it
		// (which is the case for the intended
		//  `<form onSubmit={ submit(...) }/>` use case)

		if (event && typeof event.preventDefault === 'function') {
			event.preventDefault();
		}

		// Do nothing if the form is submitting
		// (i.e. submit is in progress)
		if (_this6.state.submitting) {
			return;
		}

		// Can be used, for example, to reset
		// custom error messages.
		// (not <Field/> `error`s)
		// E.g. it could be used to reset
		// overall form errors like "Form submission failed".
		if (onBeforeSubmit) {
			onBeforeSubmit();
		}

		// Submit the form if it's valid.
		// Otherwise highlight invalid fields.
		if (_this6.validate()) {
			_this6.executeFormAction(onSubmit, _this6.getSubmittedValues());
		}
	};

	this.focus = function (field) {
		if (field) {
			return _this6.fields[field].focus();
		}
		_this6.getFocusable().focus();
	};

	this.scroll = function (field, options) {
		return _this6.fields[field].scroll(options);
	};

	this.clear = function (field) {
		return _this6.set(field, undefined);
	};

	this.get = function (field) {
		return _this6.state.values[field];
	};

	this.set = function (field, value) {
		_this6.dispatch((0, _actions.setFieldValue)(field, value));
		// If the field is still mounted.
		if (_this6.fields[field]) {
			// Validate field value.
			_this6.dispatch((0, _actions.setFieldValidationError)(field, _this6.fields[field].validate(value)));
			// Trigger the `<Field/>`'s `onChange()` handler.
			var onChange = _this6.fields[field].onChange;

			if (onChange) {
				onChange(value);
			}
		}
	};

	this.watch = function (field) {
		if (!_this6.watchedFields[field]) {
			_this6.watchedFields[field] = true;
			_this6.watchedFieldsList.push(field);
		}
		return _this6.get(field);
	};

	this.setFormNode = function (node) {
		return _this6.form = node;
	};

	this.getSubmitButtonNode = function () {
		return _this6.form.querySelector('button[type="submit"]');
	};
}, _temp);

// Added a functional `Children` component to work around a React warning:
// "Invalid hook call. Hooks can only be called inside of the body of a function component".

exports.default = Form;
function Children(_ref17) {
	var values = _ref17.values,
	    reset = _ref17.reset,
	    set = _ref17.set,
	    clear = _ref17.clear,
	    scroll = _ref17.scroll,
	    focus = _ref17.focus,
	    watch = _ref17.watch,
	    submitting = _ref17.submitting,
	    children = _ref17.children;

	return children({
		values: values,
		reset: reset,
		set: set,
		clear: clear,
		scroll: scroll,
		focus: focus,
		watch: watch,
		submitting: submitting
	});
}

Children.propTypes = {
	values: _propTypes2.default.object,
	reset: _propTypes2.default.func.isRequired,
	set: _propTypes2.default.func.isRequired,
	clear: _propTypes2.default.func.isRequired,
	scroll: _propTypes2.default.func.isRequired,
	focus: _propTypes2.default.func.isRequired,
	watch: _propTypes2.default.func.isRequired,
	submitting: _propTypes2.default.bool,
	children: _propTypes2.default.func.isRequired
};

function generateInitialFormState() {
	var initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	var _ref18 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref18$submitting = _ref18.submitting,
	    submitting = _ref18$submitting === undefined ? false : _ref18$submitting;

	return {
		// `mounted`/`unmounted` counters for each form field.
		fields: {},

		// Current form field values.
		values: {},

		// Initial form field values.
		initialValues: initialValues,

		// Externally set `error`s on form fields.
		errors: {},

		// The results of `validate()` functions called on
		// the corresponding form field `value`s.
		validationErrors: {},

		// Whether should show field errors.
		showErrors: {},

		// Is used for tracking abandoned forms for Google Analytics.
		latestFocusedField: undefined,

		// If `onSubmit` returns a `Promise` (or is `async/await`)
		// then `submitting` will be `true` until `onSubmit` finishes.
		submitting: submitting
	};
}

var contextPropType = exports.contextPropType = _propTypes2.default.shape({
	fields: _propTypes2.default.object.isRequired,
	values: _propTypes2.default.object.isRequired,
	initialValues: _propTypes2.default.object.isRequired,
	errors: _propTypes2.default.object.isRequired,
	validationErrors: _propTypes2.default.object.isRequired,
	showErrors: _propTypes2.default.object.isRequired,
	submitting: _propTypes2.default.bool.isRequired,
	onRegisterField: _propTypes2.default.func.isRequired,
	onUnregisterField: _propTypes2.default.func.isRequired,
	onRegisterList: _propTypes2.default.func.isRequired,
	getSubmittedValue: _propTypes2.default.func.isRequired,
	focus: _propTypes2.default.func.isRequired,
	dispatch: _propTypes2.default.func.isRequired,
	getRequiredMessage: _propTypes2.default.func.isRequired,
	getValues: _propTypes2.default.func.isRequired
});
//# sourceMappingURL=form.js.map