'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = Field;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactCreateRef = require('react-create-ref');

var _reactCreateRef2 = _interopRequireDefault(_reactCreateRef);

var _form = require('./form');

var _list = require('./list');

var _utility = require('./utility');

var _actions = require('./actions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function Field(props) {
	return _react2.default.createElement(
		_form.Context.Consumer,
		null,
		function (context) {
			return _react2.default.createElement(
				_list.ListContext.Consumer,
				null,
				function (listContext) {
					return _react2.default.createElement(FormField, _extends({}, props, {
						context: context,
						listContext: listContext }));
				}
			);
		}
	);
}

var FormField = (_temp = _class = function (_Component) {
	_inherits(FormField, _Component);

	function FormField(props) {
		_classCallCheck(this, FormField);

		// The field could register itself inside `componentDidMount`
		// but in that case initial `value` wouldn't yet be applied at mount time.
		var _this = _possibleConstructorReturn(this, (FormField.__proto__ || Object.getPrototypeOf(FormField)).call(this, props));

		_this.field = (0, _reactCreateRef2.default)();

		_this.onChange = function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			var event = args[0];

			var value = event;
			if (event && typeof event.preventDefault === 'function') {
				value = event.target.value;
			}

			// Once a user enters/erases a value in this field
			// the default `value` property no longer applies.
			// This flag won't work with `form.reset()`.
			_this.hasBeenEdited = true;

			var _this$props = _this.props,
			    context = _this$props.context,
			    onChange = _this$props.onChange;


			context.dispatch((0, _actions.setFieldValue)(_this.getName(), value));
			context.dispatch((0, _actions.setFieldValidationError)(_this.getName(), undefined));

			if (onChange) {
				onChange.apply(undefined, args);
			}
		};

		_this.onFocus = function (event) {
			var _this$props2 = _this.props,
			    context = _this$props2.context,
			    onFocus = _this$props2.onFocus;

			context.dispatch((0, _actions.fieldFocused)(_this.getName()));
			if (onFocus) {
				onFocus(event);
			}
		};

		_this.onBlur = function (event) {
			var _this$props3 = _this.props,
			    context = _this$props3.context,
			    onBlur = _this$props3.onBlur;

			var error = _this.validate(context.values[_this.getName()]);
			if (error) {
				context.dispatch((0, _actions.setFieldValidationError)(_this.getName(), error));
			}
			if (onBlur) {
				onBlur(event);
			}
		};

		_this.focus = function () {
			// `.focus()` could theoretically maybe potentially be called in a timeout,
			// so check if the component is still mounted.
			if (!_this.mounted) {
				return;
			}
			if (!_this.field.current) {
				return;
			}
			if (typeof _this.field.current.focus === 'function') {
				return _this.field.current.focus();
			}
			// Generic DOM focusing.
			var node = _this.getNode();
			if (node) {
				node.focus();
			} else {
				console.error('Couldn\'t focus on field "' + _this.getName() + '": DOM Node not found. ' + STATELESS_COMPONENT_HINT);
			}
		};

		_this.scroll = function (options) {
			// `.scroll()` could theoretically maybe potentially be called in a timeout,
			// so check if the component is still mounted.
			if (!_this.mounted) {
				return;
			}
			var node = _this.getNode();
			if (node) {
				(0, _utility.scrollTo)(node, options);
			} else {
				console.error('Couldn\'t scroll to field "' + _this.getName() + '": DOM Node not found. ' + STATELESS_COMPONENT_HINT);
			}
		};

		_this.validate = function (value) {
			var _this$props4 = _this.props,
			    context = _this$props4.context,
			    validate = _this$props4.validate,
			    required = _this$props4.required;

			value = context.getSubmittedValue(value);
			if (required && isValueEmpty(value)) {
				return typeof required === 'string' ? required : context.getRequiredMessage();
			}
			if (validate) {
				// `context.values` could be replaced with
				// something else, like `context.getValues()`
				// because `<List/>` values are prefixed in `context.values`.
				// But running RegExps and re-creating the object
				// on each `validate()` call seems like a not-the-best architecture.
				// Instead `values` could be replaced with something like
				// `context.getValues()` but that would be a "breaking change" in the API.
				// On a modern CPU a single `context.getValues()` run is about 0.005 ms.
				// So I guess it's acceptable, since the API already exists.
				return validate(value, context.getValues());
			}
		};

		_this.register();
		return _this;
	}

	_createClass(FormField, [{
		key: 'getName',
		value: function getName() {
			var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
			var listContext = props.listContext,
			    i = props.i,
			    name = props.name;

			if (listContext) {
				return listContext.getFieldName(i, name);
			}
			return name;
		}
	}, {
		key: 'register',
		value: function register() {
			var _props = this.props,
			    context = _props.context,
			    listContext = _props.listContext,
			    error = _props.error,
			    name = _props.name,
			    value = _props.value,
			    onChange = _props.onChange;

			// "Register" the field and initialize it with the default value.
			//
			// React will reuse and reshuffle existing `<Fields/>`
			// when hiding/showing new fields, so a field might get
			// "registered"/"unregistered" several times in those cases.
			//

			context.onRegisterField(this.getName(), {
				value: value,
				onChange: onChange,
				error: error,
				validate: this.validate,
				scroll: this.scroll,
				focus: this.focus
			});

			if (listContext) {
				listContext.onRegisterField(name);
			}
		}
	}, {
		key: 'unregister',
		value: function unregister(prevProps) {
			var context = this.props.context;

			context.onUnregisterField(this.getName(prevProps));
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.mounted = true;
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			// "Unregister" field.
			this.unregister();
			this.mounted = false;
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			var _props2 = this.props,
			    context = _props2.context,
			    value = _props2.value,
			    error = _props2.error;

			// If React reused one `<Field/>` element for another form field
			// then handle this type of situation correctly.

			if (this.getName() !== this.getName(prevProps)) {
				// Unregister old field.
				this.unregister(prevProps);
				// Register new field.
				this.register();
			}
			// Else, if it's still the same field.
			else {
					// If the default value changed for this `<Field/>`
					// and the field hasn't been edited yet
					// then apply this new default value.
					// A default value isn't supposed to generate an error.
					if (value !== prevProps.value && !this.hasBeenEdited) {
						context.dispatch((0, _actions.setFieldValue)(this.getName(), value));
					}
					// If an externally set `error` property is updated,
					// then update invalid indication for this field accordingly.
					// If the same error happened once again,
					// then it should have been reset
					// before sending form data to the server,
					// and in that case it will be shown once again.
					if (prevProps.error !== error) {
						this.showOrHideExternallySetError(error);
					}
				}
		}
	}, {
		key: 'showOrHideExternallySetError',
		value: function showOrHideExternallySetError(error) {
			var context = this.props.context;


			var value = context.values[this.getName()];
			var showError = context.showErrors[this.getName()];

			// If the `error` is set then indicate this field as being invalid.
			if (error) {
				context.dispatch((0, _actions.setFieldError)(this.getName(), error));
				// `setFieldError()` action also automatically sets `showErrors[field]` property.
				// context.dispatch(showFieldError(this.getName()))
				this.scroll();
				this.focus();
			}
			// If the `error` is reset and the field is valid
			// then reset invalid indication.
			// `!this.validate(value)` means "the value is valid".
			else if (!error && !this.validate(value)) {
					context.dispatch((0, _actions.setFieldError)(this.getName(), undefined));
				}
		}
	}, {
		key: 'getNode',
		value: function getNode() {
			if (this.field.current) {
				// Using `ReactDOM.findDOMNode` instead of `this.field.current`
				// to supports non-functional components that don't use `React.forwardRef()`.
				// For example, `<DropFileUpload/>` from `react-responsive-ui`.
				//
				// Using `useImperativeHandle()` would throw an error here:
				// "Argument appears to not be a ReactComponent. Keys: focus".
				//
				try {
					return _reactDom2.default.findDOMNode(this.field.current);
				} catch (error) {
					// A workaround for components that use `useImperativeHandle()`
					// for adding `ref` suport.
					if (this.field.current.getDOMNode) {
						return this.field.current.getDOMNode();
					}
					console.warn(error);
				}
			}
		}

		// Focuses on a field (can be called externally through a ref).

	}, {
		key: 'render',
		value: function render() {
			var _props3 = this.props,
			    context = _props3.context,
			    required = _props3.required,
			    disabled = _props3.disabled,
			    component = _props3.component;


			var value = context.values[this.getName()];
			var error = context.validationErrors[this.getName()] || context.errors[this.getName()];
			var showError = context.showErrors[this.getName()];

			return _react2.default.createElement(component, _extends({}, (0, _utility.getPassThroughProps)(this.props, FormField.propTypes), {
				ref: this.field,
				onChange: this.onChange,
				onFocus: this.onFocus,
				onBlur: this.onBlur,
				disabled: disabled || context.submitting,
				error: showError ? error : undefined,
				required: required ? true : false,
				value: value
			}));
		}
	}]);

	return FormField;
}(_react.Component), _class.propTypes = {
	name: _propTypes2.default.string.isRequired,
	component: _propTypes2.default.elementType.isRequired,
	required: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),

	value: _propTypes2.default.any,
	error: _propTypes2.default.string,
	validate: _propTypes2.default.func,

	context: _form.contextPropType.isRequired,
	listContext: _list.listContextPropType,
	i: _propTypes2.default.number
}, _temp);


function isValueEmpty(_) {
	return _ === undefined || _ === null || Array.isArray(_) && _.length === 0;
}

var STATELESS_COMPONENT_HINT = 'For example, if it\'s a "stateless" component then rewrite it as a "React.Component" having a ".focus()" method.';
//# sourceMappingURL=field.js.map