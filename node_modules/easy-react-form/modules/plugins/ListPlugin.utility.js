'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.convertListValues = convertListValues;
exports.getListValue = getListValue;
exports.getFieldName = getFieldName;

var _utility = require('../utility');

var LIST_ITEM_KEY_REGEXP = /^([^:]+):(\d+):([^:]+)$/;

/**
 * Converts values having keys `${list}:${i}:${field}`
 * into arrays of objects `{ list: [{ field, ... }, ...] }`.
 *
 * For example, in a form, there's a `<List name="list">` container element
 * and inside that container element there're 3 `<Field name="value"/>` elements.
 *
 * Then, in `values` argument, there'd be 3 fields names corresponding to those list items:
 * * "list:0:value": "a"
 * * "list:1:value": "b"
 * * "list:2:value": "c"
 *
 * After calling this function, a new `values` object is returned
 * where those 3 entries have been replaced with a single entry:
 * * "list": [{ value: "a" }, { value: "c" }]
 *
 * @param {object} values
 * @return {object}
 */
function convertListValues(values) {
	// `values` are converted to `actualValues`.
	var actualValues = {};
	var listNames = [];
	for (var _iterator = Object.keys(values), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
		var _ref;

		if (_isArray) {
			if (_i >= _iterator.length) break;
			_ref = _iterator[_i++];
		} else {
			_i = _iterator.next();
			if (_i.done) break;
			_ref = _i.value;
		}

		var key = _ref;

		var value = values[key];
		var match = key.match(LIST_ITEM_KEY_REGEXP);
		if (match) {
			var _match = _slicedToArray(match, 4),
			    unused = _match[0],
			    list = _match[1],
			    index = _match[2],
			    name = _match[3];

			if (!actualValues[list]) {
				actualValues[list] = [];
			}
			if (!actualValues[list][index]) {
				actualValues[list][index] = {};
			}
			actualValues[list][index][name] = value;
			if (listNames.indexOf(list) < 0) {
				listNames.push(list);
			}
		} else {
			actualValues[key] = value;
		}
	}
	// Compact lists: remove removed items.
	// When an item is removed indexes are not shifted.
	// Example:
	// "list:0:value": "a"
	// "list:2:value": "c"
	// Result:
	// "list": [{ value: "a" }, { value: "c" }]
	for (var _iterator2 = listNames, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
		var _ref2;

		if (_isArray2) {
			if (_i2 >= _iterator2.length) break;
			_ref2 = _iterator2[_i2++];
		} else {
			_i2 = _iterator2.next();
			if (_i2.done) break;
			_ref2 = _i2.value;
		}

		var listName = _ref2;

		actualValues[listName] = actualValues[listName].filter(function (_) {
			return _;
		});
	}
	return actualValues;
}

/**
 * Gets a value by path `${list}:${i}:${field}`
 * from an object having shape `{ list: [{ field, ... }, ...] }`.
 * @param {object} values
 * @param {string} key
 * @return {any} Returns `NOT_FOUND` if the value wasn't found.
 */
function getListValue(values, key) {
	var match = key.match(LIST_ITEM_KEY_REGEXP);
	if (match) {
		var _match2 = _slicedToArray(match, 4),
		    unused = _match2[0],
		    list = _match2[1],
		    index = _match2[2],
		    name = _match2[3];

		return values[list] && values[list][index] && values[list][index][name];
	}
	return _utility.NOT_FOUND;
}

function getFieldName(listName, i, name) {
	return listName + ':' + i + ':' + name;
}
//# sourceMappingURL=ListPlugin.utility.js.map