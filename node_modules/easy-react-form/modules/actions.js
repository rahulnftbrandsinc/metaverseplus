"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
var registerField = exports.registerField = function registerField(_ref) {
	var field = _ref.field,
	    value = _ref.value,
	    validate = _ref.validate,
	    error = _ref.error;
	return function (state) {
		// Uses a numerical counter instead of a boolean.
		// https://github.com/erikras/redux-form/issues/1705
		// If the value is `0` then it means that the field
		// has been previously initialized so not reinitializing it.
		// This also preserves the initial value of the field.
		// Because a user may choose some value which would result in
		// a couple of new form fields to appear above this field,
		// and so React unmounts this field only to later mount it again
		// a couple of new form fields lower.
		// So this trick retains the field's state (including value).
		if (state.fields[field] === undefined) {
			state.fields[field] = 1;

			// Only initializes the field with its default `value`
			// if it hasn't been seen before.
			state.values[field] = value;
			state.validationErrors[field] = validate(value);

			if (error) {
				state.errors[field] = error;
				state.showErrors[field] = true;
			}
		} else {
			state.fields[field]++;
		}
	};
};

var unregisterField = exports.unregisterField = function unregisterField(field) {
	return function (state) {
		// Uses a numerical counter instead of a boolean.
		// https://github.com/erikras/redux-form/issues/1705
		// Even if the registration counter for a field
		// becomes equal to `0` it's still not destroyed,
		// because theoretically it could be a new field
		// being added in the beginning of the form
		// therefore causing all field to unregister and then register again.
		// If those fields were destroyed then their values would be lost.
		state.fields[field]--;
	};
};

// Sets field `value`.
// (e.g. `this.form.set(field, value)`).
var setFieldValue = exports.setFieldValue = function setFieldValue(field, value) {
	return function (state) {
		state.values[field] = value;
	};
};

// Sets field externally-set `error`.
var setFieldError = exports.setFieldError = function setFieldError(field, error) {
	return function (state) {
		state.errors[field] = error;
		state.showErrors[field] = Boolean(state.validationErrors[field] || state.errors[field]);
	};
};

// Sets field validation `error`.
var setFieldValidationError = exports.setFieldValidationError = function setFieldValidationError(field, error) {
	return function (state) {
		state.validationErrors[field] = error;
		state.showErrors[field] = Boolean(state.validationErrors[field] || state.errors[field]);
	};
};

var fieldFocused = exports.fieldFocused = function fieldFocused(field) {
	return function (state) {
		state.latestFocusedField = field;
	};
};

var setFormSubmitting = exports.setFormSubmitting = function setFormSubmitting(submitting) {
	return function (state) {
		state.submitting = submitting;
	};
};

var showFieldError = exports.showFieldError = function showFieldError(field) {
	return function (state) {
		state.showErrors[field] = true;
	};
};

var removeField = exports.removeField = function removeField(field) {
	return function (state) {
		delete state.fields[field];
		delete state.values[field];
		delete state.errors[field];
		delete state.validationErrors[field];
		delete state.showErrors[field];
		if (state.latestFocusedField === field) {
			state.latestFocusedField = undefined;
		}
	};
};
//# sourceMappingURL=actions.js.map